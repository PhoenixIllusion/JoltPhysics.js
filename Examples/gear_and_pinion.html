<!DOCTYPE html>
<html lang="en">
	<head>
		<title>JoltPhysics.js demo</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link rel="stylesheet" type="text/css" href="style.css">
	</head>
	<body>
		<div id="container">Loading...</div>
		<div id="info">JoltPhysics.js gear and rack-and-pinion</div>

		<script src="js/three/three.min.js"></script>
		<script src="js/three/OrbitControls.js"></script>
		<script src="js/three/WebGL.js"></script>
		<script src="js/three/stats.min.js"></script>
		<script src="js/example.js"></script>

		<script type="module">
			// In case you haven't built the library yourself, replace URL with: https://www.unpkg.com/jolt-physics/dist/jolt-physics.wasm-compat.js
		import initJolt from 'https://www.unpkg.com/jolt-physics/dist/jolt-physics.wasm-compat.js';

			initJolt().then(function (Jolt) {
				// Initialize this example
				initExample(Jolt, null);
				camera.position.z -= 15;
				camera.position.y -= 5;

				// Create a basic floor
				let floor = createFloor();
				floor.SetFriction(1.0);

        // Create material for wheel
        const texLoader = new THREE.TextureLoader();
        const texture = texLoader.load('data:image/gif;base64,R0lGODdhAgACAIABAAAAAP///ywAAAAAAgACAAACA0QCBQA7');
        texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
        texture.offset.set(0, 0);
        texture.repeat.set(1, 1);
        texture.magFilter = THREE.NearestFilter;

        const pos = new Jolt.RVec3(1,0,0);
        const rot = Jolt.Quat.prototype.sRotation(pos, 0.5 * Math.PI)
        function createGearWheel(x,y, radius, color) {
					const shape = new Jolt.CylinderShape(0.1, radius/2, 0.05, null);
          pos.Set(x, y, 0);
					const creationSettings = new Jolt.BodyCreationSettings(shape, pos, rot, Jolt.EMotionType_Dynamic, LAYER_MOVING);
					const body = bodyInterface.CreateBody(creationSettings);
          addToScene(body, color);

			    const gear = dynamicObjects[dynamicObjects.length - 1];
          const material = new THREE.MeshPhongMaterial({ color });
          material.map = texture;
          gear.material = material;
          return body;
        }
        
        const gearSetting = new Jolt.HingeConstraintSettings();
        gearSetting.mPoint1.Set(0,4,0.5);
        gearSetting.mPoint2.Set(0,4,0.5);
        gearSetting.mHingeAxis1.Set(0,0,1);
        gearSetting.mHingeAxis2.Set(0,0,1);
        gearSetting.mNormalAxis1.Set(1,0,0);
        gearSetting.mNormalAxis2.Set(1,0,0);

        const axisSize = new Jolt.RVec3(0.2, 0.2, 0.2);
        pos.Set(0,4,1);
        const bigAxis = createBox(pos, Jolt.Quat.prototype.sIdentity(), axisSize, Jolt.EMotionType_Static, LAYER_NON_MOVING, 0xFF0000);
        const bigGear = createGearWheel(0, 4, 3, 0xFF0000);

        const gear1 = Jolt.castObject(gearSetting.Create(bigAxis, bigGear), Jolt.HingeConstraint);
        physicsSystem.AddConstraint(gear1);

        gear1.SetMotorState(Jolt.EMotorState_Velocity);
        gear1.SetTargetAngularVelocity(1);

        pos.Set(2.1, 4, 1);
        const smallAxis = createBox(pos, Jolt.Quat.prototype.sIdentity(), axisSize, Jolt.EMotionType_Static, LAYER_NON_MOVING);
        const smallGear = createGearWheel(2.1, 4, 1, 0x00FF00);
        
        gearSetting.mPoint1.Set(2.1, 4,0.5);
        gearSetting.mPoint2.Set(2.1, 4,0.5);
        const gear2 = Jolt.castObject(gearSetting.Create(smallAxis, smallGear), Jolt.HingeConstraint);
        physicsSystem.AddConstraint(gear2);

        const gearConstraintSettings = new Jolt.GearConstraintSettings();
        gearConstraintSettings.mHingeAxis1.Set(0,0,1);
        gearConstraintSettings.mHingeAxis2.Set(0,0,1);
        gearConstraintSettings.mRatio = 5;
        const gearConnection = Jolt.castObject(gearConstraintSettings.Create(smallGear, bigGear), Jolt.GearConstraint);
        physicsSystem.AddConstraint(gearConnection);

        gearConnection.SetConstraints(gear2, gear1);


        pos.Set(4.2, 4, 1);
        const bigAxis2 = createBox(pos, Jolt.Quat.prototype.sIdentity(), axisSize, Jolt.EMotionType_Static, LAYER_NON_MOVING);
        const bigGear2 = createGearWheel(4.2, 4, 3, 0xFFFF00);

        gearSetting.mPoint1.Set(4.2, 4,0.5);
        gearSetting.mPoint2.Set(4.2, 4,0.5);
        const gear3 = Jolt.castObject(gearSetting.Create(bigAxis2, bigGear2), Jolt.HingeConstraint);
        physicsSystem.AddConstraint(gear3);

        const gearConnection2 = Jolt.castObject(gearConstraintSettings.Create(smallGear, bigGear2), Jolt.GearConstraint);
        physicsSystem.AddConstraint(gearConnection2);

        gearConnection.SetConstraints(gear2, gear3);



        pos.Set(7, 8, 1);
        const pinionConnect = createBox(pos, Jolt.Quat.prototype.sIdentity(), axisSize, Jolt.EMotionType_Static, LAYER_NON_MOVING, 0xFF00FF);
        pos.Set(7, 8, 0);
        axisSize.Set(0.2, 5, 0.2);
        const pinion = createBox(pos, Jolt.Quat.prototype.sIdentity(), axisSize, Jolt.EMotionType_Dynamic, LAYER_MOVING, 0xFFFFFF);

        const sliderConstraintSettings = new Jolt.SliderConstraintSettings();
        sliderConstraintSettings.mPoint1.Set(5, 8,0.5);
        sliderConstraintSettings.mPoint2.Set(5, 8,0.5);
        sliderConstraintSettings.mNormalAxis1.Set(1,0,0);
        sliderConstraintSettings.mNormalAxis2.Set(1,0,0);
        sliderConstraintSettings.mSliderAxis1.Set(0,1,0);
        sliderConstraintSettings.mSliderAxis2.Set(0,1,0);
        const slider = Jolt.castObject(sliderConstraintSettings.Create(pinionConnect, pinion), Jolt.SliderConstraint);
        physicsSystem.AddConstraint(slider);
        

        const rackAndPinionSetting = new Jolt.RackAndPinionConstraintSettings();
        rackAndPinionSetting.mSliderAxis.Set(0,1,0);
        rackAndPinionSetting.mHingeAxis.Set(0,0,1);
        rackAndPinionSetting.mRatio = 3;
        const rackAndPinion = Jolt.castObject(rackAndPinionSetting.Create(bigGear2, pinion), Jolt.RackAndPinionConstraint);
        physicsSystem.AddConstraint(rackAndPinion);
        
			});

		</script>
	</body>
</html>
